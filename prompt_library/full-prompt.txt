<purpose>
    We are generating spaced-repetition flashcards from economics class notes.
</purpose>

<instructions>
    <instruction>Use only the provided notes {{notes-from-lecture}} to create the flashcards.</instruction>
    <instruction>Do not output any code, commentary, or formatting other than the question::answer format.</instruction>
    <instruction>Each flashcard should be formatted exactly as "Question::Answer" on a single line.</instruction>
    <instruction>No extra content outside of these lines. Only produce the flashcards.</instruction>
    <instruction>At least 10 flashcards total.</instruction>
</instructions>

<examples>
    <example>
        What is GDP?::Gross Domestic Product is the total value of all goods and services produced within a country over a specific period.
        Define elasticity of demand.::Elasticity of demand measures how the quantity demanded of a good changes in response to a price change.
    </example>
</examples>

<notes-from-lecture>
1. to make things easier, they recommend the Laravel Herd app that manages your php versions and servers.  On Windows, this definitely made it quick and easy.  On Mac, I'm going a different route -> we're gonna try to do this all on our own.  `brew install php` + `brew install composer` is all we needed.   `composer serve` gets the program up and running for local dev.
2. Laravel offers a scaffolding system (like many others) that walks you through options for your application.  We haven't learned a lot of them yet, but we'll get there.  
3. Most of our work so far has been in `/app/resources/views` we created the required `/components` directory for our blade components/layouts/partial files that mimic other languages like ruby and blazor
4. The tutorial began with the `/app/resources/routes` file.  We added a few routes that tells php to serve the blade components and pages.  There's a one-to-one mapping between the route endpoints and the main blade files that live in `/views` but **not** `/views/components`.  Routes are simple, and follow the pattern: `Route::get('/endpoint', function() { return view('endpoint') });`. I assume `view('blah')` directly refers to the blade files in the top level `views` directory.  
5. Components can be large or small layout files.  We have, so far, added components for our nav links as well as an overall page layout.  Defining a layout is as simple as saving some html in the `/views/components` directory following the pattern of `my-named-component.blade.php` Files in the main `/views` directory can access those with the `<x-` tag.  For example, to get the "my-named-component" into one of our main views, we can just add `<x-my-named-component>` (needs the closing tag) and it'll render.  
6. Injecting data into these views.  Children of the component are accessed mainly by applying a `{{ $slot }}` member, which seems to just mean 'inject whatever here'.  You can, however, have named props.  In our component, we need a directive (it can be an array) of values, like so: `@props(['active', 'selected'])` we can then use those in our component by referring them with the `$active` or `$name-of-prop-in-array`.  To send named props into the component, we write:  `<x-nav-link href="/" :active='false' ... >` The colon ensures we're getting the real `false` value in this case.  Otherwise a non-empty string is obviously truthy and would fail.  
7. We can pass data into our views in the route handler.  For example, in our `Router::get(;\jobs\{id}', funciton($id) { // setup data heree all strings` we can get the `$job` from our array by just using `Arr::first($jobs, fn($job) => $job['key'] == $id` then pass it into our view (with any var name) like `return view('page', ['newVarName' => $job]);` Then `newVarName` can be accessed in the view as a variable (`$newVarName['id'])`, etc...  pretty handy, really
8. We need the namespaces.  `Job` as a class can obviously have collisions if not appropriately separated out.  we do define these namespaces with backslash `\` characters, however.  So our `Job` model would be in the `namespace App\Models` to behave appropriately.  To use this class, you just have to say `use App\Models\Job` and you get full access to it.
9. Database defaults to SQLite.  But making models is easy.  Definitely run `php artisan` to see the list - specifically in the `migrate` section.  If we just run `php composer migrate` it'll only run the migrations that it hasn't performed already.  Running `php artisan make:migration xxx` will create a new migration file. To run all of the migrations again, run `php artisan migrate:refresh` will run **all** of the migration files again.  
10. We use `Illuminate\Database\Eloquent\x` for our ORM.  Creating a class and extending it with `Job extends Modal` and including this library gives us all the goodies we'd expect from an ORM.  
11. Once our class modal extends this type, we _have_ to determine which fields are writable.  We can set these with `protected $fillable = ['column_we_can_write_to', ...]` only then will we be able to perform CRUD operations on that data.  
12. Given sqlite already has a `jobs` table, we can keep our class named `Job` and point it to use our `job_listings` table by adding `protected $table = 'job_listings` or whichever table we need.
13. PHP has a REPL!  You can access it with `php artisan tinker` <--- good to know
14. To add items to the database in the REPL, we use `App\Models\Movie::create('column_name' => 'column_value');` 
15. `APP_DEBUG` in our `.env` file will allow us to turn on and off additional debugging in our application - it'll appear as a bottom bar with significantly more information.  
16. `HasFactory` seems pretty powerful.  It uses `faker` underneath and can be used to create tons of fake data.  We can call the factory (in `php artisan tinker`) by typing something like: `App\Models\User::factory(100)->create();` and it'll create 100 fake users!  Make sure to ensure that the `database\factories\UserFactory.php` file has the correct columns defined.  Ours initially failed after we'd updated `name` to `first_name last_name`. Faker had values for `firstName lastName`, which we also changed.
17. when using faker to create data, we need an additional function to represent several people who's emails aren't verified.  Note that we're setting `email_verified` to `now()`.  Luckily, there's a method provided at the bottom, in my case, the function is `casts()`, which hashes the password and set's the `email_verified_at` to `null`.  Call this in tinker by calling it before `create` like so: `App\Models\User::factory()->casts()->create();`
18. **Day 12** we added the `public function employer() { return $this->belongsTo(Employer::class); }` to show that a job is **owned** by the employer.  Likewise, we added `public function job() { return $this->hasMany(Job::class); }` to the employer to show that an employer can have many jobs associated with it.  These relationships are critical for just about all applications.  Eloquent/ORM makes this pretty simple.  Note that we do not call `employer()` as a function: we just allow eloquent/laravel to make that association `$job->employer->name`
19. Pivot tables exist to provide references to objects in other tables.  Some issues can occur in sqlite, however.  When a record is created that utilizes the pivot table and the exterior records (pointing AT the pivot table) are deleted, sqlite will **not**, by default, delete the record in the pivot table.  You have to turn this on in the database by running `PRAGMA foreign_keys=ON`. This ensures that the corresponding record in the privot is also removed.
20. Day 12 may need re-watching: pivot tables and calling methods vs accessing properties is a little wonky.  Also, the relationships we're using are `belongsToMany(Job::class);` or similar.  The `Tag` class has the same thing, but in reverse.  Also, the migrations were a little weird.  In the `tags` migration file, it's basically just two columns setup like so.  `$table->foreignIdFor(\App...\Job::class, 'job_listing_id')->constrained()->cascadeOnDelete();` and same for Tag class without the secondary parameter to the foreignId parameter...  We may have to delve deeper into this.
21. Day 13.  We discussed the [[N plus 1 Problem]] and ways to combat multiple db queries in our apps.  We do this by using Eloquent's `::with()` method.  In our example, we know `Job` has an `employer` (implemented as a function).  When we request `Jobs::all()` we load **all** of the employers with individual requests.  Instead, we save our `$jobs = Job::with('employer')->get();`, which eagerly loads relevant data in one swoop, drastically reducing the number of queries we're making to our database.  Additionally, we disabled lazy loading entirely in our `AppServiceProvider.php` file by writing `Model::preventLazyLoading();` in the `boot()` method (which runs after all other initialization in your project).  We also had to add the package [debugbar]([barryvdh/laravel-debugbar: Debugbar for Laravel (Integrates PHP Debug Bar) (github.com)](https://github.com/barryvdh/laravel-debugbar)) , which allows us to see the number of requests we're making to our database.  Super helpful.
22. Day 14 Pagination.  This was pretty easy to implement.  Originally, our get jobs route called for ALL of the records in the Jobs directory.  `::with` made this even more calls due to the cascading of stuff.  Instead, we implemented the stuff above.  Limiting the number of items on our screen/list was easy by adding `$jobs = Job::with('employer')->paginate(3);` this gives us only 3 records at a time - **but** the _cool_ thing was just going to the `jobs.blade.php` file and updating it with `<div> {{ $jobs->links() }}` we automatically got pagination controls, defaulted to using tailwind.  Additionally, we ran `php artisan vendor:publish` which adds a `../views/vendor` folder which contains those default objects (which you can update, too).  `paginate()` has a few other options `->simplePaginate(3)` doesn't provide the list of pages to select, and `->cursor()` does similarly, but hashes the location of the next page, kind of destroying our url for sharing.
23. Day 15 database seeders.  We can create these just like anything else `php artisan make:seeder` and enter the name.  When we run `php artisan migrate:refresh --seed` it'll automatically run the defaulted `DatabaseSeeder.php` file (we can specify others) which generates whatever you'd like.  These seeders utilize the factory methods you've already setup for your classes.  Pretty neat, actually.
24. Day 16 forms.  Updated folder structure per the rest protocol.  Job views were all moved into `views/jobs`.  The all jobs page `jobs.blade.php` was renamed to `index.blade.php` then the single job view was renamed to `show.blade.php`.  Finally, we added a `create.blade.php` file that included the form used to display on the `jobs/create` route (which we added to our route file).  One important thing about wildcards `/job/{id}` is that it's a catch-all.  Do not define anything below it, or it won't work.  We copied a form from tailwindui.com and deleted a bunch of stuff that we don't need.  `<form method="POST" action="/jobs">` was added to make sure the form had the correct action.  We also updated the important `for=""` and `name=""` values to their respective values (title and salary in this instance).  We added `@csrf` as a directive within the form to tokenize the client's session, ensuring no injectable attack could happen (and also allow laravel to work).  Finally, we updated our `Route::post('\jobs', function() {}` to create a new job.  Here's how: `Job::create([ 'title' => request('title'), 'salary' => request('salary'), // then spoofed the employer_id for now])` the return was `return redirect('/jobs')`. To ensure this new job was at the topmost in the list, we added to our get to `/jobs` to `$jobs = Job::with('employer')->latest()->simplePaginate(3);` which is just one way to see the latest created entries with Eloquent ORM.
25. Day 17 input validation.  We definitely let the client side provide the immediate feedback when an input is `required` - just add that to the end of the input block.  Adding validation to our post router, however, there's an easy way to catch these errors: `request()->validate([ 'key' => ['required', 'min:3' ], 'anotherKey' => ['required'] ]);` When the form submission fails, Laravel will return the **same page with an error array**. You can access it with `@error('title') {{ $message }} @endError` feel free to style the `$message` however you'd like.  As always, you can find other specific ways to validate in the Laravel docs [here]([Validation - Laravel 11.x - The PHP Framework For Web Artisans](https://laravel.com/docs/11.x/validation)). 
26. Day 18 Path, update and delete.  HTML doesn't normally support PATCH or DELETE.  Luckily, laravel comes through with more directives.  In the HTML `<form>` element, set the method to `<form method="POST" action="">` with the `@method('PATCH')` to let laravel know you're just updating the record.  In our `web.php` file, it behaves as you'd expect: both `Route::patch` and `Route::delete` are there, and we're following the same uri schema.  Both will be made to `Route::patch('/jobs/{id}`.  We were introduced to a more straight-forward way to handle possibly requesting a record that doesn't exist: `$job = Job::findOrFail($id);` just so it returns when `null` is encountered.  In our update request, we simply validate the data, `findOrFail` in assigning the job, then `$job->update([ 'key' => request('key') ]);` just like we did on creation.  `DELETE` is even easier: `$job = Job::findOrFail(id)->delete();`. In both cases, we `redirect()` Patch makes sense to redirect to `/jobs/ . $job->id` (note the period for concatenation), delete simply redirects to `/jobs`.  
27. Day 19 routes and controllers, wow.  We made a route controller using `php artisan create:controller` without having a name, which we were prompted for.  Note there are other options than `Empty`, which is likely worth exploring.  It's absolutely **critical** that we use the verbs defined in example class: `public function index, create, show, store, edit, update, destroy` and make relevant methods for those (we ripped out the logic in our routes and pasted them in the relevant functions).  Once complete, we updated our `web.php` file's routes with `Route::get('/jobs', [JobController::class, 'index']);` and similar.  Then, we found out about `Route::controller(JobController::class)->group(function () { ... our routes here for get update and all that });` which was a wonderful way to visually see our routes and could be good for small pages that we have for navigation on a sidebar/whatever.  Finally, we learned aobut `Route::resource('jobs', JobController::classs);` which was wonderful, but only works if we follow along with their determined verb naming.  This removed the `App\Models\Job` dependency completely from the `web.php` file, which was amazing.  While performing these tasks, we also were introduced to `php artisan list:route --except-vendor` which lists **all** of our written routes!  `Route::resource('/jobs', JobController::class, [ 'except' => ['route I don't want' ...], 'only' => ['just the routes I want']]);` allows us to only include or exclude certain routes, as well (3rd argument (as an array) passed to the `Route::resource())` function.  This lang is pretty dope!
28. Day 20 had us utilize the breeze template to learn about how a professional developer may layout their projects.  Not a lot of hand's on, just _look and see_. 
29. Day 21, laying out our forms for registration and login.  Made gratuitous use of blades for different sections of the forms.  They came in very handy.  `web.php` was updated with these new routes kinda following along the lines of the `Route::get('/path', [RouteController, 'routeMethod']);` paradigm, which I like.  `php artisan make:controller ControllerName` was also used.  PHP storm seems like a winner here - may be good to download if we're doing this.  We were also introduces to hiding and showing buttons based on log in with either `@guest <stuff /> @endguest` and `@auth <stuff />  @endauth`. 
30. Day 22, finishing login and auth.  This went pretty quick and laravel provides some really easy ways. The `SessionController`'s `store()` method is used to first validate the fields we needed to `['email', 'password']` which we saved to an `$attributes` variable.  We then passed that variable to `Illuminate\Support\Facades\Auth::attempt($var)`, if it failed, we threw a new `Illuminate\Validation\ValidationException::messages([ 'email' => 'sorry we couldn't log you in' ]);` then we regenerated the session with `request()->session()->regenerate();` super simple.  Follow all that with a `return redirect('/');`. and it just worked.  Pretty easy.  We also added a method to log the user out.  Note that logging out _should_ be a `POST`, not a `GET` to avoid session hijacking.  so we created a `Route::post('/logout', [SessionController, 'destroy']);` which we handled with `Illuminate\Support\Facades\Auth::logout();` then redirected back to root. Overall, this is incredibly easier than node.
31. Day 23 -> auth.  `Illuminate\Support\Facades\Auth` and `\Gate`.  These have middleware and other helpful functions to intercept the current user and see if they're the owner of the current record.  `\Gate` is an interesting class: we can define a gate in a specific route in a Controller class, add a general/global rule in `AppServiceProvider.php`.  `Gate`'s need to be `defined` first: `Gate::define('edit-job', function(User $user, Job $job) { return $job->employer->user->is($user); });` this creates the `edit-job` gate locally in the function and checks to see if the currently logged in user == owner of the record.  Note that before all of the above, we added a `user` function to the `Employer` model with `return $this->belongsTo(User::class);`.  This sets the relationship.  A `php artisan migrate:fresh --seed` was in order to add the column to the `Employer` model/database.  Eventually, we added the `Gate::define(...)` to the `AppServiceProvider` to create a global Gate.  Several methods/properties for `user` and `employer` were discussed, specifically `->is() ->isNot ->can() ->cannot()`, each of which apply to the `Illuminate\Support\Facades\Auth or \Gate` laravel lib. Note that while I followed along, everything broke until we added the last piece `JobPolicy` to the mix.  
</notes-from-lecture>